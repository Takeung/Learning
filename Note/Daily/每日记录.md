# 每日记录

- [每日记录](#每日记录)
  - [周报：2024.8.12~8.16](#周报2024812816)
    - [2024.8.14](#2024814)
      - [缩减电源状态上报数据信息](#缩减电源状态上报数据信息)
      - [UART数据接收完成立即清空FIFO缓存](#uart数据接收完成立即清空fifo缓存)
      - [进入OTA升级模式后启动计时，超时后退出恢复业务核运行](#进入ota升级模式后启动计时超时后退出恢复业务核运行)
    - [2024.8.13](#2024813)
      - [UART数据持续稳定收发](#uart数据持续稳定收发)
      - [梳理OTA安全升级策略](#梳理ota安全升级策略)
    - [2024.8.12](#2024812)
      - [检视TZ提供的精简版代码](#检视tz提供的精简版代码)
      - [发现Bug：UART数据发一段时间后会卡乱码并停发](#发现buguart数据发一段时间后会卡乱码并停发)
  - [周报：2024.8.5~8.9](#周报20248589)
    - [2024.8.9](#202489)
      - [支持输上报版本号及运行分区信息](#支持输上报版本号及运行分区信息)
    - [2024.8.8](#202488)
      - [读取全部ADC用电状态](#读取全部adc用电状态)
    - [2024.8.7](#202487)
      - [UART单通道OTA刷写与调试log回显测试](#uart单通道ota刷写与调试log回显测试)
      - [读取全部ADC用电状态](#读取全部adc用电状态-1)
    - [2024.8.6](#202486)
      - [UART异步读取解析更改适配同步策略](#uart异步读取解析更改适配同步策略)
    - [2024.8.5](#202485)
      - [调试TZ提供的新版OTA代码](#调试tz提供的新版ota代码)
  - [周报：2024.7.29~8.2](#周报202472982)
    - [2024.8.2](#202482)
      - [针对错序的UART命令增加重排策略](#针对错序的uart命令增加重排策略)
      - [异步读取不稳定，需要更改为同步执行](#异步读取不稳定需要更改为同步执行)
    - [2024.8.1](#202481)
      - [UART接收数据后回显给SOC](#uart接收数据后回显给soc)
      - [UART接收数据的处理逻辑](#uart接收数据的处理逻辑)
    - [2024.7.31](#2024731)
    - [2024.7.30](#2024730)
      - [一体机MCU电源状态监控：初版方案开发完成](#一体机mcu电源状态监控初版方案开发完成)
      - [总结梳理IAR工程调试配置文件缺失定位记录](#总结梳理iar工程调试配置文件缺失定位记录)
    - [2024.7.29](#2024729)
  - [周报：2024.7.22~26](#周报202472226)
    - [2024.7.26](#2024726)
      - [OTA非预期问题汇总](#ota非预期问题汇总)
      - [MCU与ROS远程上下电及电源状态监控功能联调验证成功](#mcu与ros远程上下电及电源状态监控功能联调验证成功)
    - [2024.7.25](#2024725)
    - [2024.7.24](#2024724)
      - [更新已知内容](#更新已知内容)
      - [新问题与新方向](#新问题与新方向)
    - [2024.7.23](#2024723)
      - [编码](#编码)
      - [总结](#总结)
    - [2024.7.22](#2024722)
  - [周报：2024.7.15~19](#周报202471519)
    - [2024.7.19](#2024719)
      - [熟悉MCU OTA版本IAR工程源码](#熟悉mcu-ota版本iar工程源码)
      - [MCU OTA版本代码上下电功能简单测试](#mcu-ota版本代码上下电功能简单测试)
    - [2024.7.18](#2024718)
      - [一体机MCU电源状态监控](#一体机mcu电源状态监控)
      - [一体机上下电单控毫米波雷达](#一体机上下电单控毫米波雷达)
      - [一体机上下电单控相机](#一体机上下电单控相机)
    - [2024.7.17](#2024717)
    - [2024.7.16](#2024716)
    - [2024.7.15](#2024715)
  - [周报：2024.7.8~12](#周报20247812)
  - [周报：2024.7.1~5](#周报2024715)

## 周报：2024.8.12~8.16

### 2024.8.14

#### 缩减电源状态上报数据信息

包计数和版本分区信息不再标注说明，其他信息只保留一位字母缩写，如有电压则保留电压

```c
SOC_Printf("??\r\n%u\r\n", ++g_trans_packet_cnt);
SOC_Printf("%s\r\n", CURRENT_VERSION_PARTITION);
SOC_Printf("H: %0.2f %%\r\n", g_humidity);
SOC_Printf("T: %0.2f °C\r\n", g_temperature);
SOC_Printf("O12: %0.2f A, %0.2f V\r\n", g_shunt_current_all[0][0], g_bus_voltage_all[0][0]);
SOC_Printf("O5: %0.2f A, %0.2f V\r\n", g_shunt_current_all[0][1], g_bus_voltage_all[0][1]);
SOC_Printf("N5_1: %0.2f A, %0.2f V\r\n", g_shunt_current_all[0][2], g_bus_voltage_all[0][2]);
SOC_Printf("N5_2: %0.2f A, %0.2f V\r\n", g_shunt_current_all[1][0], g_bus_voltage_all[1][0]);
SOC_Printf("E5: %0.2f A, %0.2f V\r\n", g_shunt_current_all[1][1], g_bus_voltage_all[1][1]);
SOC_Printf("P5: %0.2f A, %0.2f V\r\n", g_shunt_current_all[1][2], g_bus_voltage_all[1][2]);
SOC_Printf("L24: %0.2f A, %0.2f V\r\n", g_shunt_current_all[2][0], g_bus_voltage_all[2][0]);
SOC_Printf("8_12: %0.2f A, %0.2f V\r\n", g_shunt_current_all[2][1], g_bus_voltage_all[2][1]);
SOC_Printf("M12: %0.2f A, %0.2f V\r\n", g_shunt_current_all[2][2], g_bus_voltage_all[2][2]);
SOC_Printf("S3V3: %0.2f V\r\n", g_adc_voltage_all[0]);
SOC_Printf("S1V8: %0.2f V\r\n", g_adc_voltage_all[1]);
SOC_Printf("S3V3: %0.2f V\r\n", g_adc_voltage_all[2]);
SOC_Printf("S1V8: %0.2f V\r\n", g_adc_voltage_all[3]);
SOC_Printf("E3V3: %0.2f V\r\n", g_adc_voltage_all[4]);
SOC_Printf("E1V8: %0.2f V\r\n", g_adc_voltage_all[5]);
SOC_Printf("E1V5: %0.2f V\r\n", g_adc_voltage_all[6]);
SOC_Printf("E1V1: %0.2f V\r\n", g_adc_voltage_all[7]);
SOC_Printf("E0V88: %0.2f V\r\n", g_adc_voltage_all[8]);
SOC_Printf("E1V2: %0.2f V\r\n", g_adc_voltage_all[9]);
SOC_Printf("5G3V8: %0.2f V\r\n", g_adc_voltage_all[10]);
SOC_Printf("P1V8: %0.2f V\r\n", g_adc_voltage_all[11]);
SOC_Printf("P3V3: %0.2f V\r\n", g_adc_voltage_all[12]);
SOC_Printf("L3V3: %0.2f V\r\n", g_adc_voltage_all[13]);
SOC_Printf("N16: %0.2f V\r\n", g_adc_voltage_all[14]);
SOC_Printf("N27: %0.2f V\r\n", g_adc_voltage_all[15]);
SOC_Printf("N38: %0.2f V\r\n!!", g_adc_voltage_all[16]);
```

#### UART数据接收完成立即清空FIFO缓存

当前TZ实现方案中，UART接收数据的方案使用的是例程中的中断方案，而非ringBuffer方案，所以尝试增加Cy_SCB_UART_StartRingBuffer以调整ringBuffer缓存区大小的想法测试失败，原因在于未按照实际例子去阻塞运行。了解到本身应用为中断方案之后，可以在接收数据完成之后立即清除当前FIFO中的数据，如此每次接收道德数据互相之间没有干扰，始终能够保证接收到的每一帧数据都是从指定帧头开始，重复测试下来未遇到错序情况（实际上存储时应该同时用到了ringBuffer和FIFO，但是优先存在FIFO中）。故而新的解决方案可以取代重排策略。

#### 进入OTA升级模式后启动计时，超时后退出恢复业务核运行

完成定时器中断的移植，但调测发现周期设置修改不生效，暂不能确定是何处出错，待定位。

### 2024.8.13

#### UART数据持续稳定收发

系统启动后，状态监控数据总能稳定发送一段时间，而发送数据长度不同时，开始出现乱码并停发数据的时间也不太一样，所以怀疑是资源紧张导致的UART通信阻塞（暂未定位到根本原因）。通过查看源码发现，负责发送UART数据的`UART_SendData`实际上调用的是`Cy_SCB_UART_Transmit`，而`Cy_SCB_UART_Transmit`更适用于发送单字节数据的场景，在持续发送如此大量的数据时可能会出现一些非预期问题。

另一方面，Cypress提供了一个更适合大量数据发送场景的接口`Cy_SCB_UART_PutArray`，相比于前者，它能减少中断的处理次数和上下文切换的开销，提高发送稳定性。

解决方法：更换接口：`Cy_SCB_UART_Transmit` -> `Cy_SCB_UART_PutArray`。

![](https://s2.loli.net/2024/08/13/8X1EZaTCFIHnpym.png)

更换接口后，持续测试发送稳定性（截图数据显示业务核已运行5728 * 10s ≈ 15.9h）。

#### 梳理OTA安全升级策略

梳理当前OTA的升级流程和一些已有的安全策略，整理了文档 OTA安全升级策略.md ，讨论如何保证稳定可靠的升级。

### 2024.8.12

#### 检视TZ提供的精简版代码

对比发现精简的方式是删除每个核编译构建时产生的中间产物（主要是Obj目录下的文件，以cm7_0核为例，Obj目录所占内存高达1.1GB），参照该方法，上传仓库时可以将Exe、List和Obj目录下的全部产物都删除，包括不必要的旧版本，比如rev_b。

![](https://s2.loli.net/2024/08/12/A9BC8VDWSpZc63I.png)

#### 发现Bug：UART数据发一段时间后会卡乱码并停发

MCU通过UART_SendData向SOC发送数据持续一段时间之后，SOC串口中会收到一段乱码，之后就不会再显示新的UART数据（跑在SOC上的ros服务也不能收到），但是此时由SOC向MCU发送下电指令（SOC并未断过电），MCU是能接收并处理的（MCU没死，业务程序还在跑），怀疑是UART_SendData接口有问题：
1、163的设备是以10s为周期，持续向SOC发送长度为1000的字符串；
2、141的设备是以10s为周期，持续向SOC发送长度为700的字符串。

![](https://s2.loli.net/2024/08/12/R79OqvLDBEKCrGV.png)

------

## 周报：2024.8.5~8.9

本周重点进展、问题及风险:

1、调试TZ提供的新版OTA代码，主要涉及OTA架构的更新，为方便后续维护，已将cm0核上A、B分区的源码合并到同一个文件中维护，修改后验证OTA对区刷写成功；

2、针对UART命令偶现错序的问题，原本认为UART中断接收和周期读取为异步操作，但实际上UART中断触发依赖于读取，即原本接收读取的逻辑已是同步处理。在此种情况下，暂无更好的解决方案，幸而通过数据预识别的重排策略（对错序的数据按“帧头-payload-帧尾顺序排列），重复验证能够稳定解决数据错序的问题，故而考虑暂且采用现有方案；

3、在A样裸板MCU和SOC间只有单条UART通道的硬件环境下，测试同时进行OTA版本刷写与调试log回显任务，实测发现SOC侧可能是因为负载过高等问题导致刷写失败和log数据丢失（本质上刷写失败也是丢数据所致）。该问题会直接影响到A样整机（137、141）远程刷写的成功率，当前硬件版本无法解决，只能在B样硬件增加UART资源后才能解决；

4、MCU最新软件版本支持读取全部17路ADC电压、9路INA3221电压电流以及当前软件版本和运行分区号，并以10秒为周期持续上报给SOC。

下周工作计划:

1、针对TZ提供的最新精简源码，识别差异并更新MCU_BSP仓库；

2、针对TZ即将提供MCU支持GPIO心跳的工程源码，识别更新并验证功能；

3、由于当前MCU工程源码并未使用freertos，出于性能需求和可维护性考虑，尝试对现有工程做移植适配，初期将以源码优化开始着手。

### 2024.8.9

#### 支持输上报版本号及运行分区信息

增加当前版本和分区信息以10秒周期上报给SOC；增加读取17路ADC电压以10秒周期上报给SOC：涉及到BSP配置修改和ADC模块源码增改；增加调试相关log上报给SOC；增加5s定时器任务；整理ADC、INA3221、UART、定时器以及cm0和cm7_0核源码排版格式，删除不必要的宏定义、变量及函数声明和定义。

### 2024.8.8

#### 读取全部ADC用电状态

通过与TZ的开发人员沟通获悉，当前交付的IAR工程源码版本中，需要增改配置方可使用，包括在cm7_0核增加包含ADC的头文件和源码、修改cpress-traveo_ii-bsp_freertos/tviibh8m/hdr/rev_c/bb_bsp_tviibh8m.h中有关ADC中断源的配置，增改完成后能够正常调度接口并打印ADC原始数据，验证完成，可以开发。

### 2024.8.7

#### UART单通道OTA刷写与调试log回显测试

在A样裸板MCU和SOC间只有单条UART通道的硬件环境下，测试同时进行OTA版本刷写与调试log回显任务，实测发现SOC侧可能是因为负载过高等问题导致刷写失败和log数据丢失（本质上刷写失败也是丢数据所致）。因为OTA刷写和log回显都是必要功能，所以新版硬件中不得不增加至两路UART，按7.29日会议结论，应当考虑扩展新的UART资源。此外，完成137、141整机MCU版本升级。

#### 读取全部ADC用电状态

当前接口尚未开发完成，可按照例程尝试读取。

### 2024.8.6

#### UART异步读取解析更改适配同步策略

原本认为UART中断接收和读取为异步操作，多次调试后发现，实际上UART中断触发依赖于读取，或者说，在调用读取函数Cy_SCB_UART_Receive之后才会触发中断Cy_SCB_UART_Interrupt，由此可认为原本接收读取的逻辑已是同步处理。
但测试下来，多次发送后UART命令出现错序的问题依然存在，但全部能够通过重排策略解决，暂且使用现有方案，后续再考虑修复该问题。

cm0核上A、B分区的源码合并到同一个文件后，验证对区升级刷写成功。

### 2024.8.5

#### 调试TZ提供的新版OTA代码

比较了新版本的更新内容，主要涉及OTA架构的更新；调试过程中尝试将cm0核上A、B分区的源码合并到同一个文件中维护，其中因为启动时序的问题，当前不得不同时维护多处宏定义，后续可视需要修复。

------

## 周报：2024.7.29~8.2

本周重点进展、问题及风险:

1、评审讨论了当前OTA版本可能存在的问题和改进建议，基本确定了优化方案；

2、开发完成了一体机MCU电源状态监控的初版方案，并简单验证通过；

3、在与ROS服务通信联调过程中，定位发现MCU收到UART命令后会回显相应命令，不利于服务接收端解析，修改相应代码后问题解决；

4、SOC模拟UART命令发给MCU时，概率性出现命令错序的问题，根本原因在于MCU接收和读取命令是异步处理，数据读取可能不完整，针对该问题，在命令解析之前增加了重排策略，保证被解析数据的格式正确，实测能够解决现有问题。

下周工作计划:

1、针对UART命令概率性错序的问题，考虑修改为同步接收和读取的方案；

2、基于天准提供的新版本OTA架构，完成现有业务代码的移植和适配，保证稳定的初版软件。

### 2024.8.2

#### 针对错序的UART命令增加重排策略

经过排查分析，UART命令出现错序的情况多半是因为，中断接收到数据后还未完全写入完成，异步读取缓存的Cy_SCB_UART_Receive就将不完整的数据写进了g_uart8_in_data，从而导致部分数据未被读到，而g_uart8_in_data这边由于长度不足导致该帧命令不处理（无响应），等到下一帧数据接收后，Cy_SCB_UART_Receive仍然只读取环形缓冲区中的前18位，其中就包括上次未读完的部分，进而导致读到的命令顺序错乱。
基于以上分析，连续两帧命令之间，出错未读到的位置是随机的，但因为稳定连续读取18位，所以一次读取的数据中总是包含了顺序正确的两段子串，将两段子串更换顺序之后重新组合即可得到正确的命令。此即重排策略。

#### 异步读取不稳定，需要更改为同步执行

UART命令概率性错序的根因还在于异步读取，需要更改为同步执行，中断触发写入数据后立即读取，或者周期读取之前增加标志判断中断写入完成。

### 2024.8.1

#### UART接收数据后回显给SOC

检视代码发现，UART数据接收完成后，立即通过Cy_SCB_UART_Transmit将数据回传SOC，但是在SOC上通过minicom却没有接收到相应的log，这是因为串口的端口与SOC预设的端口（/dev/ttysWK3）不匹配，重新在minicom上测试发现确实有回显。

![](https://s2.loli.net/2024/08/02/aS6hUAPw1GvkFEt.png)

#### UART接收数据的处理逻辑

代码里接收到数据后会触发中断，数据先被缓存到g_stc_uart8_context的环形缓冲区内，然后在receive_data调用时拷贝到g_uart8_in_data，我现在已经将receive_data的调度周期改为100ms了，g_stc_uart8_context应该是没设定缓存上限的，不会爆缓存，难道是g_stc_uart8_contex的缓存太小了吗？

### 2024.7.31

整理BeyondCompare3激活文档；

整理SOC命令行配置系统网络环境及查询硬盘信息；

整理IAR工程中UART传输收发策略和唤醒缓冲区的理解；

MCU重复接收UART指令会出现“中断不能立即触发”的问题，但并未影响指令时序（需要考虑是否为串口助手的问题还是代码bug），在与ros环境联调时出现“概率性收不到指令->进不了中断->指令错位的问题”，需要进一步定位。

### 2024.7.30

#### 一体机MCU电源状态监控：初版方案开发完成

在此前能够获取INA3221寄存器原始值并输出给Orin的方案基础上，增加了从寄存器原始值到实际电流电压值的转换处理，并简单验证通过。

#### 总结梳理IAR工程调试配置文件缺失定位记录

恢复必要的ewd文件，调整cm7_1核的软件版本为rev_c，确保未出现单核构建同时输出多个软件版本的情况。

### 2024.7.29

初步确定了影响IAR工程调试相关的文件集合：ewd文件以及cm7_1.revc相关的生成文件（设置项目默认版本为rev_c并添加UART路径头文件引用）；

组织评审讨论了当前OTA版本可能存在的问题和改进建议，基本确定了优化方案。

## 周报：2024.7.22~26

本周重点进展、问题及风险:

1、更新MCU的BSP仓库并创建IAR工程的最小集合，同步更新了一体机复位、OTA功能的测试方案；

2、完成一体机毫米波雷达、摄像头单控上下电以及电源状态监控的源码编写和测试，并在与ROS服务的联调测试中验证成功；

3、在多次使用OTA软件升级一体机裸机和样机失败导致MCU挂死无法上电的过程中，熟悉了升级脚本和I-Jet烧录器的使用，同时发起了I-Jet烧录器的采购申请；

4、粗略总结了当前MCU OTA升级版本实现上的不足，已反馈给天准的开发责任人。

下周工作计划:

1、MCU将电源状态通过UART上送给SOC的通道已打通，但是上送的信息还需要梳理明确和格式化解析；

2、Orin单控下电和上电被当做两条指令实现，但是Orin下电之后无法再监听MCU上电的命令，该设计存在漏洞，需要修复；

3、引导并配合天准的OTA开发责任人优化当前MCU OTA版本的已知问题。

### 2024.7.26

#### OTA非预期问题汇总

- 整机上电启动后无法主动进入业务核，而是维持在OTA模式，需要手动切换，不符合用户直觉；
- 上电逻辑同时分布在主核和业务核，而不是集中在单核内，导致OTA升级时需要频繁下电重启；
- UART指令发送时概率性错位导致接收端不识别，导致整机不能下电，存在功能安全风险；
- Orin单控下电和上电被当做两条指令实现，但是Orin下电之后无法再监听上电的命令了；

#### MCU与ROS远程上下电及电源状态监控功能联调验证成功

MCU_BSP库上版本因删除了部分依赖文件，无法直接使用烧录器调试，待定位。

### 2024.7.25

上午修改了三版业务软件并单刷进cm7_0核之后，验证未出现问题，但是第四次刷写后切换分区时，板子挂掉。

> 因为一旦启动刷写cm7_0核，OTA程序就会将cm7_1核一起擦除，所以怀疑是因为未刷写导致板子挂掉（后续每次刷写都要将两个核同时刷写）

完成代码验证和上传：

- **超声波雷达和摄像头单控下电复位**
- **MCU电压状态监控**

> 此前一直未能在MCU的串口助手界面显示监控log，今天定位发现是因为MCU通过UART发送给SOC的数据是在SOC一侧的串口显示，可以通过minicom输出。
>
> 注意：
> Orin的Debug口和minicom串口不是一回事，前者主要用于输出系统日志，可用于定位板子不能唤醒之类的问题。

### 2024.7.24

#### 更新已知内容

1、A分区里烧B_ORIN，B分区里烧A_ORIN，cm0核所用代码版本在A、B分区并不一样（这也是今天双区烧板之后再切分区就挂死的根本原因）；

2、MCU只能在单核运行的情况下切换分区，这种情况下是能自动起来；

3、多核情况下，MCU芯片限制无法切换分区，所以实现上是先重启进入OTA单核模式才能切换分区；

4、多核场景下只能在flash里跑，不是在ram里跑，所以flash切换后需要重新上下电执行对应分区的代码；

5、Orin启动后40秒内会扫描所有下挂硬件，如果未检测到或超时后插入，Orin不能识别对应硬件。

#### 新问题与新方向

1、将Orin_power_on执行时序提前，比如在切换分区之前，是否能不必重复上下电？

2、MCU通过OTA升级失败后版本回退，保证整机正确运行；

3、MCU控制硬件上下电，但是要缩小影响范围，保证功能安全（不能通过GPIO控制供电，否则MCU下电必然导致其他硬件全部下电）；

4、Orin接收不到其他硬件的指令后，需要重新发送升级指令，直接自行对MCU做OTA升级刷写，确保系统正常运行。

### 2024.7.23

#### 编码

编写毫米波雷达、摄像头单控上下电的控制源码，进一步编译构建得到可执行应用文件，等待测试环境升级验证。

#### 总结

输出 **Ubuntu中VSCode配置C环境** 和 **VSCode快捷键** ，以及 **IAR构建烧录全流程** ；
并与天准确认：OTA升级脚本支持cm0主核升级。

### 2024.7.22

更新MCU的BSP仓库，尝试创建IAR工程的最小集合，移除不必追踪的中间文件。
验证发现flash/settings下的配置文件为必要项，直接执行tools/iar/cleanup.bat删除整个文件夹会导致编译失败。

同步一体机复位测试方案。

------

## 周报：2024.7.15~19

本周重点进展、问题及风险:

1、熟悉MCU OTA版本IAR工程源码，并基于OTA版本代码进行上下电功能的简单测试，结果出现了整机无法启动的问题。最终会同天准同事定位得出初步结论：复现过程中连续出现过两次整机不能启动的情况，反复尝试、重新完整烧录之后，问题暂未复现，但发现新问题：在切分区之后进行整机下电时，SOC不能主动上电，需要手动拔插电源解决（该Bug已由天准认领待后续解决）。

2、对照MCU porting guide和IAR工程源码，基本确定毫米波雷达和相机单控的方案。

3、学习ROS2话题与服务、参数与动作以及常用工具相关的基础知识。

下周工作计划:

1、基于MCU OTA版本完成相机、毫米波雷达的单控上下电控制功能的进一步开发。

2、设计开发一体机MCU电源状态通过UART实现信息上报。

### 2024.7.19

#### 熟悉MCU OTA版本IAR工程源码

在cm0核新增了OTA升级功能；

将原有的cm0核上上下电控制功能迁移到cm7_0核，并新增了Orin上下电、Nano上下电的功能。

#### MCU OTA版本代码上下电功能简单测试

在141整机上尝试执行了整机下电动作，整机顺利下电但无法正常恢复上电，累计测试6次，3次成功3次失败，其中失败的场景中，

（1）一次在于原始烧录的程序直接进行整机上下电测试时，顺利退出OTA模式，整机下电后不能重启，拔插电源也不能解决；
（2）另一次在于从B区切换到A区后，需要重新插拔电源再执行“退出OTA模式”动作——卡住不能启动；
（3）还有一次在于从A区切换到B区后，需要重新插拔电源再执行“退出OTA模式”动作——卡住不能启动；

最终定位结论是：重新完整烧录之后，问题未复现，但发现在切分区之后整机下电但是SOC不能主动上电，需要手动拔插电源解决（该Bug已由天准认领待后续解决）。

### 2024.7.18

#### 一体机MCU电源状态监控

目前版本中提供了

```c
tztek_ina3221_GETShuntVoltage_ALL();
tztek_ina3221_GETBusVoltage_ALL();
```

可以用来读取INA3221电源监控芯片中的原始值，乘以系数40uv即为真实电压值，可通过以下代码转换

```c
int16_t raw_value = (rx_data[0] << 8) | rx_data[1];
float shunt_voltage = raw_value * 40.0e-6; // 转换为伏特
printf("Shunt Voltage: %.6f V\n", shunt_voltage);
```

但目前该接口实现只将电压值打印，未通过UART串口输出。故而需要

1、周期（1s）上送，创建全局变量
2、转换输出并格式化
3、通过`void UART_SendData( uint8_t *data, size_t size)`将格式化信息输出到串口，供orin接收

> 实现细节可以参考温湿度的周期上报
>
> ```c
> // 没有下电请求，执行其他周期性任务
> tztek_aht2415c_GET_ALL();
> 
> // 格式化要发送的数据字符串
> char data_string[50];
> snprintf(data_string, sizeof(data_string), "RH: %0.2f %% T: %0.2f °C\r\n", g_humidity, g_temperature);
> 
> // 发送数据到串口
> UART_SendData((uint8_t*)data_string, strlen(data_string));
> ```

#### 一体机上下电单控毫米波雷达

查询[MCU porting guide](/home/tyjt/Downloads/Documents/MCU_porting guide_CYT4BF.xlsx)可以发现，毫米波12V供电使能PIN脚为MCU上P2.7

![](https://s2.loli.net/2024/07/18/WVtEJazchuj3pI7.png)

查看IAR源码了解，系统上下电过程中会主动使能、清除该引脚状态，从而控制毫米波雷达的供电

```c
// 上电置位
Cy_GPIO_Set(USER_MM12V_PORT, USER_MM12V_PIN);
// 下电清空
Cy_GPIO_Clr(USER_MM12V_PORT, USER_MM12V_PIN);

// 引脚定义
#define USER_MM12V_PORT                    USER_MM12V_PORT1

#define USER_MM12V_PORT1                    GPIO_PRT2
#define USER_MM12V_PIN1                     7
#define USER_MM12V_PIN_MUX1                 P2_7_GPIO
```

因为毫米波雷达上下电不受时序影响，由此可以定义一个控制毫米波雷达下电重启的简易函数

```c
void mm_wave_radar_power_reset(void)
{
	// 下电清空
    Cy_GPIO_Clr(USER_MM12V_PORT, USER_MM12V_PIN);
    // 等待0.1s
    Cy_SysTick_DelayInUs(100000ul);
    // 上电置位
    Cy_GPIO_Set(USER_MM12V_PORT, USER_MM12V_PIN);
}
```

该函数可以在`void processMessage(int msg)`中直接在某个case下调用处理。

#### 一体机上下电单控相机

与毫米波雷达相似，查到相机12V供电使能PIN脚为MCU上P2.6

```c
// 上电置位
Cy_GPIO_Set(USER_CAM12V_PORT, USER_CAM12V_PIN);
// 下电清空
Cy_GPIO_Clr(USER_CAM12V_PORT, USER_CAM12V_PIN);

// 引脚定义
#define USER_CAM12V_PORT                    USER_CAM12V_PORT1

#define USER_CAM12V_PORT1                    GPIO_PRT2
#define USER_CAM12V_PIN1                     6
#define USER_CAM12V_PIN_MUX1                 P2_6_GPIO
```

因为相机上下电不受时序影响，由此可以定义一个控制相机下电重启的简易函数

```c
void camera_power_reset(void)
{
	// 下电清空
	Cy_GPIO_Clr(USER_CAM12V_PORT, USER_CAM12V_PIN);
    // 等待0.1s
    Cy_SysTick_DelayInUs(100000ul);
    // 上电置位
	Cy_GPIO_Set(USER_CAM12V_PORT, USER_CAM12V_PIN);
}
```

该函数可以在`void processMessage(int msg)`中直接在某个case下调用处理。

### 2024.7.17

完成《动手学ROS》入门篇第5章关于ROS2常用工具的学习、实操和总结；

同时学习了解了ROS2硬件控制篇。

### 2024.7.16

完成《动手学ROS》入门篇第4章关于ROS2通信之参数与动作的学习、实操和总结；

经过与天准同事沟通确认，MCU通过INA3221电源监控芯片实时监控MCU供电状态，可以调用接口`tztek_ina3221_GETShuntVoltage_ALL`和`tztek_ina3221_GETBusVoltage_ALL`获取并打印各路电压。

### 2024.7.15

完成《动手学ROS》入门篇第3章关于ROS2节点通信之话题与服务的学习、实操和总结。

------

## 周报：2024.7.8~12

本周重点进展、问题及风险:

1、梳理一体机工程源码，理清了MCU从接收Orin下发的UART上下电指令到完成复位的控制逻辑，并实测验证通过；但是发现一个潜在Bug：程序在处理接收到的UART指令时，只会在顺次发送每满14个字符时做一次匹配，一旦输入顺序错乱，就很难再输对正确指令完成复位控制（该Bug可以通过脚本或者串口助手保证正确输入顺序的方式得以规避）。

2、安装ROS2开发环境，学习ROS2节点通信基础知识。

下周工作计划:

1、一体机远程监控/上下电控制功能的进一步开发。

2、继续学习ROS2。

本周工作其他细节及思考:

查漏补缺，及时总结。

------

## 周报：2024.7.1~5

本周工作内容:

1、参加入职培训，学习项目背景和企业文化；

2、学习新手教程，申请账号并搭建开发环境；

3、学习天准提供的一体机工程源码，为MCU控制任务做准备。

下周工作计划:

在继续熟悉一体机工程源码有关上下电逻辑的基础上，按时完成远程控制一体机上下电的任务计划。