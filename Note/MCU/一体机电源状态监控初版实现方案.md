# 一体机电源状态监控初版实现方案

- [一体机电源状态监控初版实现方案](#一体机电源状态监控初版实现方案)
  - [1 需求背景](#1-需求背景)
  - [2 初版实现方案](#2-初版实现方案)
    - [2.1 总线电压](#21-总线电压)
    - [2.2 分流电压](#22-分流电压)
    - [2.3 周期调度](#23-周期调度)
  - [3 一些额外的补充信息](#3-一些额外的补充信息)
    - [3.1 滤波电阻](#31-滤波电阻)
    - [3.2 监控硬件](#32-监控硬件)


## 1 需求背景

已知需要监控的电源状态信息主要包括电流和电压两个方面，相关的数据都可以通过读取INA3221芯片的寄存器值后再自行转换得到。

三路INA3221的各三个channel所测电压对应实际硬件关系映射图

![](https://s2.loli.net/2024/07/30/kJpIQb2L7smn3ij.png)

## 2 初版实现方案

在天准提供的软件包基础上（交付版本中只读了寄存器未做转换），进一步增加了数据的转换处理，

### 2.1 总线电压

```c
//channel 1 2 3对应寄存器2 4 6
void tztek_ina3221_GET_BusVoltage(MY_IIC_Struct *MY_ina3221_Struct,uint16_t *pDat,uint8_t channel)
{
    uint8_t register_addr=0;
    uint8_t rx_data[2] = {0};
    volatile stc_SCB_t* scb_x;
    cy_stc_scb_i2c_context_t* scb_i2c_context;

    static cy_stc_scb_i2c_master_xfer_config_t i2c_master_cfg =
    {
    .slaveAddress = 0,
    .buffer       = 0,                  //写的buffer
    .bufferSize   = 0,                  //写的buffer大小
    .xferPending  = false               //发送控.  (true : 将不会生成停止位)
    };

    //选择i2c
    scb_x = MY_ina3221_Struct->USER_I2C_SCB_TYPE;
    scb_i2c_context = &MY_ina3221_Struct->g_stc_i2c_context; 
    switch(channel) {
      case 1:
          register_addr = 0x02;
          break;
      case 2:
          register_addr = 0x04;
          break;
      case 3:
          register_addr = 0x06;
          break;
      default:
          // 如果switchiic的值不在0到5之间，可以设置为NULL或者一个默认的中断服务例程
          break;
    }

    //读取写入的值
    //确定写的地址
    i2c_master_cfg.slaveAddress=MY_ina3221_Struct->SLAVE_ADDR;
    i2c_master_cfg.buffer  = &register_addr;
    i2c_master_cfg.bufferSize = 1;
    CY_ASSERT(Cy_SCB_I2C_MasterWrite(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    i2c_master_cfg.buffer = &rx_data[0];
    i2c_master_cfg.bufferSize  =  2;
    CY_ASSERT(Cy_SCB_I2C_MasterRead(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    uint16_t signed_data = (rx_data[0] << 8) + rx_data[1];
    if (signed_data & 0x8000) { // 最高位是符号位，判断是否为负数
        signed_data = (int16_t)((~signed_data + 1) & 0xFFFF); // 获取绝对值
    }
    // 去掉无效的低三位
    *pDat = signed_data >> 3;
}
```

实际使用时，再乘以芯片量程的LSB（8mv）,

![](https://s2.loli.net/2024/07/30/sjQ3nWRPlhwtMrx.png)

对应代码如下：

```c
float g_bus_voltage_all[3][3]; // 定义全局变量

uint16_t data = 0;
// 读取INA32211的总线电压
tztek_ina3221_GET_BusVoltage(&MY_INA32211_Struct, &data, 1);
g_bus_voltage_all[0][0] = data * 8.0e-3;
```

### 2.2 分流电压

```c
//channel 1 2 3对应寄存器1 3 5
void tztek_ina3221_GET_ShuntVoltage(MY_IIC_Struct *MY_ina3221_Struct,uint16_t *pDat,uint8_t channel)
{
    uint8_t register_addr=0;
    uint8_t rx_data[2] = {0};
    volatile stc_SCB_t* scb_x;
    cy_stc_scb_i2c_context_t* scb_i2c_context;

    static cy_stc_scb_i2c_master_xfer_config_t i2c_master_cfg =
    {
    .slaveAddress = 0,
    .buffer       = 0,                  //写的buffer
    .bufferSize   = 0,                  //写的buffer大小
    .xferPending  = false               //发送控.  (true : 将不会生成停止位)
    };

    //选择i2c
    scb_x = MY_ina3221_Struct->USER_I2C_SCB_TYPE;
    scb_i2c_context = &MY_ina3221_Struct->g_stc_i2c_context; 
    switch(channel) {
      case 1:
          register_addr = 0x01;
          break;
      case 2:
          register_addr = 0x03;
          break;
      case 3:
          register_addr = 0x05;
          break;
      default:
          // 如果switchiic的值不在0到5之间，可以设置为NULL或者一个默认的中断服务例程
          break;
    }

    //读取写入的值
    //确定写的地址
    i2c_master_cfg.slaveAddress=MY_ina3221_Struct->SLAVE_ADDR;
    i2c_master_cfg.buffer  = &register_addr;
    i2c_master_cfg.bufferSize = 1;
    CY_ASSERT(Cy_SCB_I2C_MasterWrite(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    i2c_master_cfg.buffer = &rx_data[0];
    i2c_master_cfg.bufferSize  =  2;
    CY_ASSERT(Cy_SCB_I2C_MasterRead(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    uint16_t signed_data = (rx_data[0] << 8) + rx_data[1];
    if (signed_data & 0x8000) { // 最高位是符号位，判断是否为负数
        signed_data = (int16_t)((~signed_data + 1) & 0xFFFF); // 获取绝对值
    }
    // 去掉无效的低三位
    *pDat = signed_data >> 3;
}
```

实际使用时，再乘以芯片量程的LSB（40uv）,

![image-20240730173909929](/home/tyjt/.config/Typora/typora-user-images/image-20240730173909929.png)

对应代码如下：

```c
float g_shunt_voltage_all[3][3]; // 定义全局变量

uint16_t data = 0;
// 读取INA32211的分流电压
tztek_ina3221_GET_ShuntVoltage(&MY_INA32211_Struct, &data, 1);
g_shunt_voltage_all[0][0] = data * 40.0e-3;
```

得到分流电压之后，运用公式

```bash
Current = ShuntVoltage / ShuntResistor
```

即可计算出实际电流。根据底软开发者说明，采样电阻是3mΩ（毫欧，不是兆欧），也即是说，各个channel通过的电流值实际就是分流电压除以3。

### 2.3 周期调度

以10s为一个周期，调度代码如下

```c
// 监控电源状态
tztek_ina3221_GETShuntVoltage_ALL();
tztek_ina3221_GETBusVoltage_ALL();

// 格式化要发送的数据字符串
char data_string[500];
int length = snprintf(data_string, sizeof(data_string),
    "##\r\n"
    "RH: %0.2f %%, T: %0.2f °C\r\n"
    "ORIN_12V: %0.2f A, %0.2f V\r\n"
    "ORIN_5V: %0.2f A, %0.2f V\r\n"
    "NX_5V_1: %0.2f A, %0.2f V\r\n"
    "NX_5V_2: %0.2f A, %0.2f V\r\n"
    "ETH_5V: %0.2f A, %0.2f V\r\n"
    "PCIE_5V: %0.2f A, %0.2f V\r\n"
    "LASER_24V: %0.2f A, %0.2f V\r\n"
    "8838_12V: %0.2f A, %0.2f V\r\n"
    "MM_RADAR_12V: %0.2f A, %0.2f V\r\n"
    "!!",
    g_humidity, g_temperature,
    g_shunt_voltage_all[0][0] / 3, g_bus_voltage_all[0][0],
    g_shunt_voltage_all[0][1] / 3, g_bus_voltage_all[0][1],
    g_shunt_voltage_all[0][2] / 3, g_bus_voltage_all[0][2],
    g_shunt_voltage_all[1][0] / 3, g_bus_voltage_all[1][0],
    g_shunt_voltage_all[1][1] / 3, g_bus_voltage_all[1][1],
    g_shunt_voltage_all[1][2] / 3, g_bus_voltage_all[1][2],
    g_shunt_voltage_all[2][0] / 3, g_bus_voltage_all[2][0],
    g_shunt_voltage_all[2][1] / 3, g_bus_voltage_all[2][1],
    g_shunt_voltage_all[2][2] / 3, g_bus_voltage_all[2][2]);

if (length >= sizeof(data_string)) {
    // 如果长度超过缓冲区大小，处理错误情况
    printf("Error: data_string buffer overflow\n");
} else {
    // 发送数据到串口
    UART_SendData((uint8_t*)data_string, strlen(data_string));
}
```

调整后初步输出格式如下：

![](https://s2.loli.net/2024/07/30/a1527pgRCloLdbO.png)

## 3 一些额外的补充信息

### 3.1 滤波电阻

实际采样中发现软件读数偏大，故而增加了10Ω电阻来滤波

![](https://s2.loli.net/2024/07/30/P7Cf2aHopFsGmJ8.png)

![](https://s2.loli.net/2024/07/30/VQUg28EuR9criIl.png)

10欧电阻只是增强信号抗干扰能力，并不影响计算公式

### 3.2 监控硬件

后三路分别是激光雷达的供电侦测，一路3588的供电侦测，一路毫米波的侦测

![](https://s2.loli.net/2024/07/30/sikG1QoPuCY5zqE.png)
