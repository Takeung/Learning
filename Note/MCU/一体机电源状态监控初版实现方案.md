# 一体机电源状态监控初版实现方案

- [一体机电源状态监控初版实现方案](#一体机电源状态监控初版实现方案)
  - [1 需求背景](#1-需求背景)
  - [2 初版实现方案](#2-初版实现方案)
    - [2.1 总线电压](#21-总线电压)
    - [2.2 分流电压](#22-分流电压)
    - [2.3 ADC电压](#23-adc电压)
      - [2.3.1 ADC数据结构定义](#231-adc数据结构定义)
      - [2.3.2 通道初始化](#232-通道初始化)
      - [2.3.3 中断事件处理](#233-中断事件处理)
      - [2.3.4 ADC通道数据读取](#234-adc通道数据读取)
    - [2.4 周期调度](#24-周期调度)
  - [3 一些额外的补充信息](#3-一些额外的补充信息)
    - [3.1 滤波电阻](#31-滤波电阻)
    - [3.2 监控硬件](#32-监控硬件)


## 1 需求背景

已知需要监控的电源状态信息主要包括电流和电压两个方面，相关的数据都可以通过读取INA3221芯片的寄存器值后再自行转换得到。

三路INA3221的各三个channel所测电压对应实际硬件关系映射图

![](https://s2.loli.net/2024/07/30/kJpIQb2L7smn3ij.png)

此外，还有17路ADC通道需要读取原始值后转换成实际电压输出。映射关系根据porting_guide得到

![](https://s2.loli.net/2024/08/12/G7NK3h4R9PlosuY.png)

## 2 初版实现方案

在天准提供的软件包基础上（交付版本中只读了寄存器未做转换），进一步增加了数据的转换处理，

### 2.1 总线电压

```c
//channel 1 2 3对应寄存器2 4 6
void tztek_ina3221_GET_BusVoltage(MY_IIC_Struct *MY_ina3221_Struct,uint16_t *pDat,uint8_t channel)
{
    uint8_t register_addr=0;
    uint8_t rx_data[2] = {0};
    volatile stc_SCB_t* scb_x;
    cy_stc_scb_i2c_context_t* scb_i2c_context;

    static cy_stc_scb_i2c_master_xfer_config_t i2c_master_cfg =
    {
    .slaveAddress = 0,
    .buffer       = 0,                  //写的buffer
    .bufferSize   = 0,                  //写的buffer大小
    .xferPending  = false               //发送控.  (true : 将不会生成停止位)
    };

    //选择i2c
    scb_x = MY_ina3221_Struct->USER_I2C_SCB_TYPE;
    scb_i2c_context = &MY_ina3221_Struct->g_stc_i2c_context; 
    switch(channel) {
      case 1:
          register_addr = 0x02;
          break;
      case 2:
          register_addr = 0x04;
          break;
      case 3:
          register_addr = 0x06;
          break;
      default:
          // 如果switchiic的值不在0到5之间，可以设置为NULL或者一个默认的中断服务例程
          break;
    }

    //读取写入的值
    //确定写的地址
    i2c_master_cfg.slaveAddress=MY_ina3221_Struct->SLAVE_ADDR;
    i2c_master_cfg.buffer  = &register_addr;
    i2c_master_cfg.bufferSize = 1;
    CY_ASSERT(Cy_SCB_I2C_MasterWrite(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    i2c_master_cfg.buffer = &rx_data[0];
    i2c_master_cfg.bufferSize  =  2;
    CY_ASSERT(Cy_SCB_I2C_MasterRead(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    uint16_t signed_data = (rx_data[0] << 8) + rx_data[1];
    if (signed_data & 0x8000) { // 最高位是符号位，判断是否为负数
        signed_data = (int16_t)((~signed_data + 1) & 0xFFFF); // 获取绝对值
    }
    // 去掉无效的低三位
    *pDat = signed_data >> 3;
}
```

实际使用时，再乘以芯片量程的LSB（8mv）,

![](https://s2.loli.net/2024/07/30/sjQ3nWRPlhwtMrx.png)

对应代码如下：

```c
float g_bus_voltage_all[3][3]; // 定义全局变量

uint16_t data = 0;
// 读取INA32211的总线电压
tztek_ina3221_GET_BusVoltage(&MY_INA32211_Struct, &data, 1);
g_bus_voltage_all[0][0] = data * 8.0e-3;
```

### 2.2 分流电压

```c
//channel 1 2 3对应寄存器1 3 5
void tztek_ina3221_GET_ShuntVoltage(MY_IIC_Struct *MY_ina3221_Struct,uint16_t *pDat,uint8_t channel)
{
    uint8_t register_addr=0;
    uint8_t rx_data[2] = {0};
    volatile stc_SCB_t* scb_x;
    cy_stc_scb_i2c_context_t* scb_i2c_context;

    static cy_stc_scb_i2c_master_xfer_config_t i2c_master_cfg =
    {
    .slaveAddress = 0,
    .buffer       = 0,                  //写的buffer
    .bufferSize   = 0,                  //写的buffer大小
    .xferPending  = false               //发送控.  (true : 将不会生成停止位)
    };

    //选择i2c
    scb_x = MY_ina3221_Struct->USER_I2C_SCB_TYPE;
    scb_i2c_context = &MY_ina3221_Struct->g_stc_i2c_context; 
    switch(channel) {
      case 1:
          register_addr = 0x01;
          break;
      case 2:
          register_addr = 0x03;
          break;
      case 3:
          register_addr = 0x05;
          break;
      default:
          // 如果switchiic的值不在0到5之间，可以设置为NULL或者一个默认的中断服务例程
          break;
    }

    //读取写入的值
    //确定写的地址
    i2c_master_cfg.slaveAddress=MY_ina3221_Struct->SLAVE_ADDR;
    i2c_master_cfg.buffer  = &register_addr;
    i2c_master_cfg.bufferSize = 1;
    CY_ASSERT(Cy_SCB_I2C_MasterWrite(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    i2c_master_cfg.buffer = &rx_data[0];
    i2c_master_cfg.bufferSize  =  2;
    CY_ASSERT(Cy_SCB_I2C_MasterRead(scb_x, &i2c_master_cfg, scb_i2c_context) == CY_SCB_I2C_SUCCESS);
    Cy_SysTick_DelayInUs(50000ul);

    uint16_t signed_data = (rx_data[0] << 8) + rx_data[1];
    if (signed_data & 0x8000) { // 最高位是符号位，判断是否为负数
        signed_data = (int16_t)((~signed_data + 1) & 0xFFFF); // 获取绝对值
    }
    // 去掉无效的低三位
    *pDat = signed_data >> 3;
}
```

实际使用时，再乘以芯片量程的LSB（40uv）,

![image-20240730173909929](/home/tyjt/.config/Typora/typora-user-images/image-20240730173909929.png)

对应代码如下：

```c
float g_shunt_voltage_all[3][3]; // 定义全局变量

uint16_t data = 0;
// 读取INA32211的分流电压
tztek_ina3221_GET_ShuntVoltage(&MY_INA32211_Struct, &data, 1);
g_shunt_voltage_all[0][0] = data * 40.0e-3;
```

得到分流电压之后，运用公式

```bash
Current = ShuntVoltage / ShuntResistor
```

即可计算出实际电流。根据底软开发者说明，采样电阻是3mΩ（毫欧，不是兆欧），也即是说，各个channel通过的电流值实际就是分流电压除以3。

### 2.3 ADC电压

#### 2.3.1 ADC数据结构定义

```c
float g_adc_voltage_all[17];		// ADC通道电压
void (*AdcIntHandler)(void);		// 函数指针

cy_stc_gpio_pin_config_t adcPinConfig =
{
    .outVal    = 0ul,
    .driveMode = CY_GPIO_DM_ANALOG,
    .hsiom     = CY_ADC_POT_PIN_MUX4,
    .intEdge   = 0ul,
    .intMask   = 0ul,
    .vtrip     = 0ul,
    .slewRate  = 0ul,
    .driveSel  = 0ul,
};

cy_stc_adc_config_t adcConfignum=
{
    .preconditionTime    = 0u,
    .powerupTime         = 0u,
    .enableIdlePowerDown = false,
    .msbStretchMode      = CY_ADC_MSB_STRETCH_MODE_1CYCLE,
    .enableHalfLsbConv   = 0u,
    .sarMuxEnable        = true,
    .adcEnable           = true,
    .sarIpEnable         = true,
};

cy_stc_adc_channel_config_t adcChannelConfig =
{
    .triggerSelection          = CY_ADC_TRIGGER_OFF,
    .channelPriority           = 0u,
    .preenptionType            = CY_ADC_PREEMPTION_FINISH_RESUME,
    .isGroupEnd                = true,
    .doneLevel                 = CY_ADC_DONE_LEVEL_PULSE,
    .pinAddress                = CY_ADC_POT_IN_NO4,
    .portAddress               = CY_ADC_PORT_ADDRESS_SARMUX0,
    .extMuxSelect              = 0u,
    .extMuxEnable              = true,
    .preconditionMode          = CY_ADC_PRECONDITION_MODE_OFF,
    .overlapDiagMode           = CY_ADC_OVERLAP_DIAG_MODE_OFF,
    .sampleTime                = 0u,
    .calibrationValueSelect    = CY_ADC_CALIBRATION_VALUE_REGULAR,
    .postProcessingMode        = CY_ADC_POST_PROCESSING_MODE_NONE,
    .resultAlignment           = CY_ADC_RESULT_ALIGNMENT_RIGHT,
    .signExtention             = CY_ADC_SIGN_EXTENTION_UNSIGNED,
    .averageCount              = 0u,
    .rightShift                = 0u,
    .rangeDetectionMode        = CY_ADC_RANGE_DETECTION_MODE_INSIDE_RANGE,
    .rangeDetectionLoThreshold = 0x0000u,
    .rangeDetectionHiThreshold = 0x0FFFu,
    .mask.grpDone              = true,
    .mask.grpCancelled         = false,
    .mask.grpOverflow          = false,
    .mask.chRange              = false,
    .mask.chPulse              = false,
    .mask.chOverflow           = false,
};

// 在函数外部声明并实例化结构体变量
/** SOC1_VDD_3V3_ADC */
adc_channel_config_t adcConfig0 = {
    .adcbase = (volatile stc_PASS_SAR_t *)CY_ADC_POT_MACRO4, // 假设CY_ADC_POT_MACRO是adcbase的正确地址
    .pinbase = (volatile stc_GPIO_PRT_t *)CY_ADC_POT_PORT4, // 假设CY_ADC_POT_PORT是pinbase的正确地址
    .pinNum = CY_ADC_POT_PIN4, // 假设0是pinNum的正确初始值
    .hsiom = CY_ADC_POT_PIN_MUX4, // 假设CY_ADC_POT_PIN_MUX是hsiom的正确初始值
    .channel = 0, // 假设ADC_LOGICAL_CHANNEL是channel的正确初始值
    .irqn = CY_ADC_POT_IRQN4, // 假设CY_ADC_POT_IRQN是irqn的正确初始值
    .handlenum = 0, // 假设0是handlenum的正确初始值
    .irqType = CPUIntIdx3_IRQn, // 假设CPUIntIdx3_IRQn是irqType的正确初始值
    .ipBlock = CY_ADC_POT_PCLK4, // 假设CY_ADC_POT_PCLK是ipBlock的正确初始值
    .pin_address_t=CY_ADC_POT_IN_NO4,
};
```

#### 2.3.2 通道初始化

```c
void tztek_adc_init(adc_channel_config_t *adcConfig)
{
    uint32_t actualAdcOperationFreq;
    uint32_t samplingCycle;
    adcPinConfig.hsiom=adcConfig->hsiom;
    Cy_GPIO_Pin_Init(adcConfig->pinbase, adcConfig->pinNum, &adcPinConfig);
    /* ADC clock divider setting */
    uint32_t periFreq = 80000000ul; 
    uint32_t divNum = DIV_ROUND_UP(periFreq, ADC_OPERATION_FREQUENCY_MAX_IN_HZ);   
    actualAdcOperationFreq = periFreq / divNum;
    uint32_t groupNum=  Cy_SysClk_GetClockGroup(adcConfig->ipBlock);
    uint32_t dividerValue=divNum - 1ul;
    Cy_SysClk_PeriphAssignDivider(adcConfig->ipBlock, CY_SYSCLK_DIV_16_BIT,0u );
    Cy_SysClk_PeriphSetDivider( groupNum,CY_SYSCLK_DIV_16_BIT,0u,dividerValue);
    Cy_SysClk_PeriphEnableDivider( groupNum, CY_SYSCLK_DIV_16_BIT, 0u);
    samplingCycle = (uint32_t)DIV_ROUND_UP((ANALOG_IN_SAMPLING_TIME_MIN_IN_NS* (uint64_t)actualAdcOperationFreq), 1000000000ull);     
    adcChannelConfig.sampleTime=samplingCycle;
    adcChannelConfig.pinAddress=adcConfig->pin_address_t;
    Cy_Adc_Init(adcConfig->adcbase, &adcConfignum);
    // 初始化ADC通道
    Cy_Adc_Channel_Init(&adcConfig->adcbase->CH[adcConfig->channel], &adcChannelConfig);
    // 注册ADC中断处理函数并启用中断
    cy_stc_sysint_irq_t irq_cfg = {
        .sysIntSrc = (cy_en_intr_t)((uint32_t)adcConfig->irqn + adcConfig->channel),
        .intIdx =adcConfig->irqType,
        .isEnabled = true
    };
    Cy_SysInt_InitIRQ(&irq_cfg);

    switch (adcConfig->handlenum) 
    {
        case 0:
            AdcIntHandler=AdcIntHandler0;
            break;
        case 1:
            AdcIntHandler=AdcIntHandler1;
            break;
        default:
            break;
    }
    Cy_SysInt_SetSystemIrqVector(irq_cfg.sysIntSrc, AdcIntHandler);
    NVIC_SetPriority(irq_cfg.intIdx, 0ul);
    NVIC_EnableIRQ(irq_cfg.intIdx);
    // 使能ADC通道
    Cy_Adc_Channel_Enable(&adcConfig->adcbase->CH[adcConfig->channel]);
    
    // Cy_Adc_Channel_SoftwareTrigger(&adcConfig->adcbase->CH[adcConfig->channel]);
}
```

#### 2.3.3 中断事件处理

```c
static void AdcIntHandler0(void)
{
    uint16_t               resultBuff[16];
    cy_stc_adc_ch_status_t statusBuff[16];
    uint8_t                resultIdx;
    cy_stc_adc_interrupt_source_t intrSource = { false };

    /* Get interrupt source */
    Cy_Adc_Channel_GetInterruptMaskedStatus(&adcConfig0.adcbase->CH[adcConfig0.channel], &intrSource);

    if(intrSource.grpDone)
    {
        /* Get the result(s) */
        Cy_Adc_Channel_GetResult(&adcConfig0.adcbase->CH[adcConfig0.channel], &resultBuff[resultIdx], &statusBuff[resultIdx]);
        Cy_SysTick_DelayInUs(100000ul);
        /* Record ADC result */
        g_adc_voltage_all[0] = resultBuff[resultIdx] * 6.6 / 4096;
        /* Display ADC result */
        // SOC_Printf("\rSOC1_VDD_3V3_ADC result = %0.2f V\r\n", g_adc_voltage_all[0]);

        /* Increment result idx */
        resultIdx = (resultIdx + 1) % (sizeof(resultBuff) / sizeof(resultBuff[0]));

        /* Clear interrupt source */
        Cy_Adc_Channel_ClearInterruptStatus(&adcConfig0.adcbase->CH[adcConfig0.channel], &intrSource);

        /* Trigger next conversion */
        // Cy_Adc_Channel_SoftwareTrigger(&adcConfig0.adcbase->CH[adcConfig0.channel]);
    }
    else
    {
        // Unexpected interrupt
        CY_ASSERT(false);
    }
}
```

#### 2.3.4 ADC通道数据读取

```c
// 发出软件触发
Cy_Adc_Channel_SoftwareTrigger(&adcConfig0.adcbase->CH[adcConfig0.channel]);
```

### 2.4 周期调度

以10s为一个周期，调度代码如下

```c
// 没有下电请求，执行其他周期性任务
tztek_aht2415c_GET_ALL();
// 读取全路ADC电压
tztek_adc_GET_ALL();
// 监控电源状态
tztek_ina3221_GETShuntVoltage_ALL();
tztek_ina3221_GETBusVoltage_ALL();

// 格式化要发送的数据字符串
char data_string[1000];
int length = snprintf(data_string, sizeof(data_string),
                      "??\r\n"
                      "TRANS_PACKET_COUNT: %u\r\n"
                      "CURRENT_VERSION_PARTITION: %s\r\n"
                      "HUMIDITY: %0.2f %%\r\n"
                      "TEMPERATURE: %0.2f °C\r\n"
                      "ORIN_12V: %0.2f A, %0.2f V\r\n"
                      "ORIN_5V: %0.2f A, %0.2f V\r\n"
                      "NX_5V_1: %0.2f A, %0.2f V\r\n"
                      "NX_5V_2: %0.2f A, %0.2f V\r\n"
                      "ETH_5V: %0.2f A, %0.2f V\r\n"
                      "PCIE_5V: %0.2f A, %0.2f V\r\n"
                      "LASER_24V: %0.2f A, %0.2f V\r\n"
                      "8838_12V: %0.2f A, %0.2f V\r\n"
                      "MM_RADAR_12V: %0.2f A, %0.2f V\r\n"
                      "SOC1_VDD_3V3_ADC: %0.2f V\r\n"
                      "SOC1_VDD_1V8_ADC: %0.2f V\r\n"
                      "SOC2_VDD_3V3_ADC: %0.2f V\r\n"
                      "SOC2_VDD_1V8_ADC: %0.2f V\r\n"
                      "ETH_VDD_3V3_ADC: %0.2f V\r\n"
                      "ETH_VDD_1V8_ADC: %0.2f V\r\n"
                      "ETH_VDD_1V5_ADC: %0.2f V\r\n"
                      "ETH_VDD_1V1_ADC: %0.2f V\r\n"
                      "ETH_VDD_0V88_ADC: %0.2f V\r\n"
                      "ETH_VDD_1V2_ADC: %0.2f V\r\n"
                      "5G_VDD_3V8_ADC: %0.2f V\r\n"
                      "PCIE_VDD_1V8_ADC: %0.2f V\r\n"
                      "PCIE_VDD_3V3_ADC: %0.2f V\r\n"
                      "LED_VDD_3V3_M_ADC: %0.2f V\r\n"
                      "N20527916: %0.2f V\r\n"
                      "N20527927: %0.2f V\r\n"
                      "N20527938: %0.2f V\r\n"
                      "!!",
                      ++g_trans_packet_cnt,
                      CURRENT_VERSION_PARTITION,
                      g_humidity, g_temperature,
                      g_shunt_current_all[0][0], g_bus_voltage_all[0][0],
                      g_shunt_current_all[0][1], g_bus_voltage_all[0][1],
                      g_shunt_current_all[0][2], g_bus_voltage_all[0][2],
                      g_shunt_current_all[1][0], g_bus_voltage_all[1][0],
                      g_shunt_current_all[1][1], g_bus_voltage_all[1][1],
                      g_shunt_current_all[1][2], g_bus_voltage_all[1][2],
                      g_shunt_current_all[2][0], g_bus_voltage_all[2][0],
                      g_shunt_current_all[2][1], g_bus_voltage_all[2][1],
                      g_shunt_current_all[2][2], g_bus_voltage_all[2][2],
                      g_adc_voltage_all[0],
                      g_adc_voltage_all[1],
                      g_adc_voltage_all[2],
                      g_adc_voltage_all[3],
                      g_adc_voltage_all[4],
                      g_adc_voltage_all[5],
                      g_adc_voltage_all[6],
                      g_adc_voltage_all[7],
                      g_adc_voltage_all[8],
                      g_adc_voltage_all[9],
                      g_adc_voltage_all[10],
                      g_adc_voltage_all[11],
                      g_adc_voltage_all[12],
                      g_adc_voltage_all[13],
                      g_adc_voltage_all[14],
                      g_adc_voltage_all[15],
                      g_adc_voltage_all[16]);

if (length >= sizeof(data_string)) {
    // 如果长度超过缓冲区大小，处理错误情况
    Term_Printf("Error: data_string buffer overflow\n");
    SOC_Printf("Error: data_string buffer overflow\n");
} else {
    // 发送数据到串口
    UART_SendData((uint8_t*)data_string, strlen(data_string));
}
```

调整后初步输出格式如下：

![](https://s2.loli.net/2024/08/12/RCEbvkd8tMznHyh.png)

> 格式化替代方案：
>
> 背景：MCU输出一段时间后不再向SOC发送数据，但仍然能接收处理下电指令，需要两帧
>
> 方案：将发送的长数据拆分之后逐条发送，并且将SOC_Printf实际使用的`Cy_SCB_UART_Transmit`替换为`Cy_SCB_UART_PutArray`
>
> ```c
> SOC_Printf("??\r\nTRANS_PACKET_COUNT: %u\r\n", ++g_trans_packet_cnt);
> SOC_Printf("CURRENT_VERSION_PARTITION: %s\r\n", CURRENT_VERSION_PARTITION);
> SOC_Printf("HUMIDITY: %0.2f %%\r\n", g_humidity);
> SOC_Printf("TEMPERATURE: %0.2f °C\r\n", g_temperature);
> SOC_Printf("ORIN_12V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[0][0] / 3, g_bus_voltage_all[0][0]);
> SOC_Printf("ORIN_5V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[0][1] / 3, g_bus_voltage_all[0][1]);
> SOC_Printf("NX_5V_1: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[0][2] / 3, g_bus_voltage_all[0][2]);
> SOC_Printf("NX_5V_2: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[1][0] / 3, g_bus_voltage_all[1][0]);
> SOC_Printf("ETH_5V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[1][1] / 3, g_bus_voltage_all[1][1]);
> SOC_Printf("PCIE_5V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[1][2] / 3, g_bus_voltage_all[1][2]);
> SOC_Printf("LASER_24V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[2][0] / 3, g_bus_voltage_all[2][0]);
> SOC_Printf("8838_12V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[2][1] / 3, g_bus_voltage_all[2][1]);
> SOC_Printf("MM_RADAR_12V: %0.2f A, %0.2f V\r\n", g_shunt_voltage_all[2][2] / 3, g_bus_voltage_all[2][2]);
> SOC_Printf("SOC1_VDD_3V3_ADC: %0.2f V\r\n", g_adc_voltage_all[0]);
> SOC_Printf("SOC1_VDD_1V8_ADC: %0.2f V\r\n", g_adc_voltage_all[1]);
> SOC_Printf("SOC2_VDD_3V3_ADC: %0.2f V\r\n", g_adc_voltage_all[2]);
> SOC_Printf("SOC2_VDD_1V8_ADC: %0.2f V\r\n", g_adc_voltage_all[3]);
> SOC_Printf("ETH_VDD_3V3_ADC: %0.2f V\r\n", g_adc_voltage_all[4]);
> SOC_Printf("ETH_VDD_1V8_ADC: %0.2f V\r\n", g_adc_voltage_all[5]);
> SOC_Printf("ETH_VDD_1V5_ADC: %0.2f V\r\n", g_adc_voltage_all[6]);
> SOC_Printf("ETH_VDD_1V1_ADC: %0.2f V\r\n", g_adc_voltage_all[7]);
> SOC_Printf("ETH_VDD_0V88_ADC: %0.2f V\r\n", g_adc_voltage_all[8]);
> SOC_Printf("ETH_VDD_1V2_ADC: %0.2f V\r\n", g_adc_voltage_all[9]);
> SOC_Printf("5G_VDD_3V8_ADC: %0.2f V\r\n", g_adc_voltage_all[10]);
> SOC_Printf("PCIE_VDD_1V8_ADC: %0.2f V\r\n", g_adc_voltage_all[11]);
> SOC_Printf("PCIE_VDD_3V3_ADC: %0.2f V\r\n", g_adc_voltage_all[12]);
> SOC_Printf("LED_VDD_3V3_M_ADC: %0.2f V\r\n", g_adc_voltage_all[13]);
> SOC_Printf("N20527916: %0.2f V\r\n", g_adc_voltage_all[14]);
> SOC_Printf("N20527927: %0.2f V\r\n", g_adc_voltage_all[15]);
> SOC_Printf("N20527938: %0.2f V\r\n!!", g_adc_voltage_all[16]);
> ```
>
> 注：函数Cy_SCB_UART_PutArray中，硬件fifo最大只有128，长数据需要分批发送。

## 3 一些额外的补充信息

### 3.1 滤波电阻

实际采样中发现软件读数偏大，故而增加了10Ω电阻来滤波

![](https://s2.loli.net/2024/07/30/P7Cf2aHopFsGmJ8.png)

![](https://s2.loli.net/2024/07/30/VQUg28EuR9criIl.png)

10欧电阻只是增强信号抗干扰能力，并不影响计算公式

### 3.2 监控硬件

后三路分别是激光雷达的供电侦测，一路3588的供电侦测，一路毫米波的侦测

![](https://s2.loli.net/2024/07/30/sikG1QoPuCY5zqE.png)
